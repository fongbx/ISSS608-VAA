---
title: "Take-home Exercise 1"
subtitle: "Visual Analysis on the City of Engagement"
author: "Fong Bao Xian"
date: "6 May 2023"
date-modified: "`r Sys.Date()`"
---

# Overview

The objective of this exercise is to reveal the demographic and financial characteristics of the City of Engagement. Using appropriate analytical visualisations, the exercise aims to help city managers and planners of the City of Engagement explore the data for their usage.

The datasets used are the following:

-   **Participants.csv** - contains demographic information about the residents
-   **FinancialJournal.csv** - contains information about financial transactions

# Getting Started

## Import R Packages

For this exercise, we will be using the following packages:

-   `tidyverse` - a collection of packages for data science and analysis, including packages for data import, wrangling and visualisation
-   `lubridate` - for working with dates and timestamp
-   `ggstatsplot` -
-   `plotly`
-   `gglorenz` - for plotting of Lorenz Curves

We will use `pacman::p_load` to install (if the packages are not yet installed) and load the packages into the R environment in a single command.

```{r}
pacman::p_load(tidyverse, lubridate, zoo, ggstatsplot, plotly, crosstalk, gglorenz, DescTools, wesanderson, rstatix, webshot2, png, gt, ggridges, gganimate, hrbrthemes)
```

## Import Data

We will read in the two datasets using `read_csv()` function from the `readr` package and store them as tibbles. A tibble is a modern, tidy data frame format in R which is designed to work better with the tidyverse package.

```{r}
participants <- read_csv("data/Participants.csv")
financial <- read_csv("data/FinancialJournal.csv")
```

# Data Preparation

## Change to appropriate data format

We will first convert the variables into appropriate data format:

-   **Participants** dataset:
    -   Convert ***householdSize*** from numerical to factor using `factor()` as there are only three categories
    -   Convert ***educationalLevel*** and ***interestGroup*** from character to factor using `factor()` and setting the level as necessary using the level argument
-   **FinancialJournal** dataset:
    -   Convert ***category*** from character to factor using `factor()`

```{r}
# Convert householdSize, educationalLevel and interestGroup to factor
participants$householdSize <- factor(participants$householdSize)
participants$educationLevel <- factor(participants$educationLevel, levels = c("Low", "HighSchoolOrCollege", "Bachelors", "Graduate"))
participants$interestGroup <- factor(participants$interestGroup)

# Convert category to factor
financial$category <- factor(financial$category)
```

## Bin age into age_groups

The ***age*** variable is currently in continuous format. We will bin them into ***age_groups*** using `cut()` function to facilitate subsequent analysis.

```{r}
participants <- participants %>% 
  mutate(age_groups = cut(age, breaks = c(18,30,40,50,60), include.lowest = TRUE))
```

We can take a look at the distribution of the age_groups in the following:

```{r}
table(participants$age_groups)
```

## Extract year month from timestamp

From the ***timestamp*** variable in the **FinancialJournal** dataset, we will also extract the relevant year and month information using `as.yearmon()` from `zoo` package.

```{r}
# Extract year and month
financial$yearmonth <- factor(as.yearmon(financial$timestamp))
```

## Remove duplicates in data

Checking for duplicates using `duplicated()`, we find that there are 1,113 duplicated rows in the **FinancialJournal** dataset. Taking a glimpse into the duplicated rows, we see that for some of the participants, their monthly shelter and education expenses have been duplicated for the same timestamp.

```{r}
# Check for duplicates in records
dup_rows <- duplicated(financial)
sum(dup_rows)
```

```{r}
# Taking a look at all the duplicated rows
head(financial[dup_rows, ])
```

We will remove the duplicates using `distinct()` from the `dplyr` package to keep only the unique data.

```{r}
financial <- distinct(financial)
```

## Aggregating financial data per participant per yearmonth

Currently, the financial data is in long format, with **participantId** repeated across the rows for each timestamp and category of financial transaction. For more meaningful analysis of the financial data by participants, we will prepare the data as follows:

-   Aggregate the total amount for each category of financial transaction for each yearmonth for each participant using `group_by()`
-   Narrow down to the necessary columns using `select()`
-   Convert the data from long to wide format using `pivot_wider()` to pivot the data frame so that the **categor**y column becomes the names of the new columns, the **amount** column becomes the values in those columns, and the values are summed up for each **participantId** and **yearmonth** combination
-   Replace all NA values with 0 using `replace(is.na(.), 0)`
-   Compute a new variable **AdjustedShelter** to offset the Shelter expenses with the RentAdjustments (considered as relief received in relation to Shelter expenses) using `mutate()`
-   Change all expense category (including Education, Food, Recreation and AdjustedShelter) to positive amounts for easier analysis and visualisation using `mutate(across())` the columns and applying the function to multiply with -1
-   Compute a new variable **CostOfLiving** to facilitate analysis of a participant's total expenses using `mutate()`
-   Select the final required variables using `select()` and round all the monetary figures to two decimal places

```{r}
# Aggregate financial data per participant per yearmonth
financial_yearmth <- financial %>%
  group_by(participantId, yearmonth) %>%
  select(participantId, yearmonth, category, amount) %>% 
  pivot_wider(names_from = category,
              values_from = amount,
              values_fn = sum) %>% 
  replace(is.na(.), 0) %>%
  mutate(AdjustedShelter = Shelter + RentAdjustment) %>% 
  mutate(across(c(Education, Food, Recreation, AdjustedShelter), function(x) x*-1)) %>%
  mutate(CostOfLiving = Education + Food + Recreation + AdjustedShelter) %>% 
  select(participantId, yearmonth, Wage, Education, Food, Recreation, AdjustedShelter, CostOfLiving) %>%
  mutate(across(Wage:CostOfLiving, function(x) round(x, 2)))
```

Below is a glimpse of how the aggregated data looks like:

```{r}
head(financial_yearmth %>% arrange(participantId))
```

## Dropping participants with incomplete data

After aggregating per participant per yearmonth, it was noted that there were 131 participants with only one month of transaction. It could be that there are no longer residents of the City of Engagement or they had withdrawn from the study midway.

```{r}
# Group by participantId and count the number of months of transactions
count_mths <- financial_yearmth %>% group_by(participantId) %>%
  summarise(mths_accounted = n())

# Find number of participants with only one month of transactions
participants_withdrawn <- count_mths[count_mths$mths_accounted == 1, ]$participantId
length(participants_withdrawn)
```

For more accurate analysis, we will exclude these 131 participants from our data by using `filter()` function to filter out participants who are not in the list of withdrawn participants.

```{r}
financial_yearmth <- financial_yearmth %>%
  filter(!participantId %in% participants_withdrawn)
```

## **Aggregating financial data per participant**

While aggregating financial data per participant per yearmonth allow us to observe the financial status of each participant over the months, we will also further aggregate the financial data per participant taking his/her total income or expenses across the entire study period (12 months).

The following are the steps taken:

-   As the financial_yearmth tibble had earlier been grouped using both **participantId** and **yearmonth**, we will need to ungroup it using the function ungroup() before we can drop the **yearmonth** column using select(-yearmonth)
-   Then we can group by **participantId** and do an aggregation across the income and expense columns using summarise()

```{r}
# Aggregate financial data per participant
financial_agg <- financial_yearmth %>%
  ungroup() %>%
  select(-yearmonth) %>%
  group_by(participantId) %>%
  summarise(across(Wage:CostOfLiving, sum)) %>%
  mutate(across(Wage:CostOfLiving, function(x) round(x, 2)))
```

Below is a glimpse of how the aggregated data looks like:

```{r}
head(financial_agg %>% arrange(participantId))
```

## Merging participant demographics data with financial data

Next, we merge the participants dataset with the aggregated financial data using the function `inner_join()`, joined by **participantId**.

```{r}
combined <- participants %>% inner_join(financial_agg, by = "participantId")
```

Below is a glimpse of how the merged data looks like:

```{r}
head(combined)
```

# Data Visualisation

## Demographics of the residents

First, we will have an overview understanding of the demographics of residents in the City of Engagement using the charts below.

```{r}
#| code-fold: true
#| code-summary: "Show code"
#| fig-width: 7
#| fig-height: 8

# Plot age
age <- ggplot(data = combined, aes(x = age_groups,
                                         fill = age_groups)) +
  geom_bar() +
  geom_text(
    aes(label = scales::percent(after_stat(prop)), group = 1),
    stat = "count",
    vjust = 1.5) +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank(),
        legend.position = "none") +
  ggtitle("Proportion by Age Groups") +
  scale_fill_manual(values = wes_palette("Chevalier1"))
  
# Plot householdSize
household <- ggplot(data = combined, aes(x = householdSize,
                                         fill = householdSize)) +
  geom_bar() +
  geom_text(
    aes(label = scales::percent(after_stat(prop)), group = 1),
    stat = "count",
    vjust = 1.5) +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank(),
        legend.position = "none") +
  ggtitle("Proportion by Household Size") +
  scale_fill_manual(values = wes_palette("Chevalier1"))

# Plot educationLevel
education <- ggplot(data = combined, aes(x = educationLevel,
                                         fill = educationLevel)) +
  geom_bar() +
  geom_text(
    aes(label = scales::percent(after_stat(prop)), group = 1),
    stat = "count",
    vjust = 1.5) +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank(),
        legend.position = "none") +
  ggtitle("Proportion by Education Level") +
  scale_fill_manual(values = wes_palette("Chevalier1"))

# Plot haveKids
kids <- ggplot(data = combined, aes(x = haveKids, fill = haveKids)) +
  geom_bar() +
  geom_text(
    aes(label = scales::percent(after_stat(prop)), group = 1),
    stat = "count",
    vjust = 1.5) +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank(),
        legend.position = "none") +
  ggtitle("Proportion Having Kids") +
  scale_fill_manual(values = wes_palette("Chevalier1"))

# Plot interestGroups
interest <- ggplot(data = combined, aes(x = interestGroup,
                                        fill = interestGroup)) +
  geom_bar() +
  geom_text(
    aes(label = scales::percent(after_stat(prop)), group = 1),
    stat = "count",
    vjust = 1.5) +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank(),
        legend.position = "none") +
  ggtitle("Proportion by Interest Groups") +
  scale_fill_manual(values = wes_palette("Chevalier1", 10, type = "continuous"))

# Combine plots
patch_plt1 <- (age + household) / (education + kids) / interest
patch_plt1 + patchwork::plot_layout(guides = "collect") +
    patchwork::plot_annotation(title = "Demographics in the City of Engagement", 
                    theme = theme(plot.title = element_text(hjust = 0.5,
                                                            size = 18)))
```

::: callout-note
## Key Observations

-   Participants of the survey range between 18 and 60 years old. The spread of residents among the age groups are fairly even.
-   The proportion of household sizes are fairly even between 1 and 3. Household sizes in the City of Engagement are relatively small since the maximum household size is 3.
-   The majority of the residents have education level of at least High School or College and above.
-   A large proportion of the residents (72%) do not have children.
-   The proportion across the various interest groups are fairly even.
:::

## Distribution of Income in the Population

Next, we also want to understand the income distribution among the residents in the City of Engagement. We do so by plotting the histogram and boxplot of the income of all participants.

```{r}
#| code-fold: true
#| code-summary: "Show code"

plt_box <- ggplot(data = combined, aes(x = Wage)) +
  geom_boxplot(fill = "#d3dddc", color = "#456455") +
  theme(axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.major = element_blank()) +
  coord_cartesian(xlim=c(20000, 250000))

plt_hist <- ggplot(data = combined, aes(x = Wage)) +
  geom_histogram(bins = 35, fill = "#d3dddc", color = "#456455") +
  coord_cartesian(xlim=c(20000, 250000))

patch_plt2 <- plt_box / plt_hist
patch_plt2 + patchwork::plot_layout(heights = c(1,3),
                                    guides = "collect") +
    patchwork::plot_annotation(title = "Distribution of Income in City of Engagement", 
                    theme = theme(plot.title = element_text(hjust = 0.5,
                                                            size = 18)))
```

::: callout-note
## Key Observations

-   The income distribution is positively-skewed, with a right tail. This tells us that the majority of the population has lower income, with fewer individuals earning higher incomes.
-   The presence of outliers on the right also indicate that there are some extreme high-income earners that are relatively rare in the population.
:::

We will further plot the Lorenz curve below, which is a more mathematical graphical representation of the spread of income over a population. At any point in the curve, we can find a cumulative percentage of the population and see how much of the cumulative share of income they hold.

The shaded area between the Lorenz curve and the straight diagonal line, which represents perfect equality in income distribution, is the Gini Coefficient. A Gini Coefficient of 0 represents perfect equality and 1 represents highest inequality.

```{r}
#| code-fold: true
#| code-summary: "Show code"

ggplot(data = combined, aes(x = Wage)) +
  stat_lorenz(geom = "polygon", alpha = 0.65, fill = "#d3dddc") +
  geom_abline(linetype = "dashed", linewidth = 0.8, color = "#456455") +
  coord_fixed() +
  theme_minimal() +
  hrbrthemes::scale_x_percent() +
  hrbrthemes::scale_y_percent() +
  theme(legend.title = element_blank()) +
  labs(x = "Cumulative % of Population",
       y = "Cumulative % of Income",
       title = "Lorenz Curve for Distribution of Income in\nCity of Engagement ") +
  annotate_ineq(combined$Wage)
```

::: callout-note
## Key Observation

In the City of Engagement, the Lorenz curve deviates slightly from the straight diagonal line and the Gini Coefficient is 0.27. As a guideline, a Gini Coefficient value between 0.2 - 0.3 represents relative equality. This shows that overall, there did not seem to be an issue of big income gap. It might however still be worth looking into whether income differs by any particulars groups of demographic profiles.
:::

## Distribution of Income and Expense Categories among different Demographic Profiles

We now want to drill in further to understand how income and the different expense categories differ by the different demographic profiles. For such exploration, an interactive plot would be useful.

::: callout-tip
## Interactive Chart

-   Select from the dropdown menus to change the variables on the x-axis and y-axis
-   Hover over the charts to view the key statistics
:::

```{r}
#| code-fold: true
#| code-summary: "Show code"
#| fig-width: 12
#| fig-height: 10

# Initiate the base plot
plot_ly(data = combined,
        x = ~age_groups,
        y = ~Wage,
        type = 'box',
        boxmean = 'sd',
        boxpoints = 'all',
        jitter=0.3,
        pointpos=-1.8,
        hoverinfo = "y",
        fillcolor = "#d3dddc") |> 

# Generate plot, x-axis, and y-axis title
  layout(title = "Boxplot of Income/Expenses vs Selected Demographic Profiles\n(over 12-month period)",
         xaxis = list(title = "Age Groups"),
         yaxis = list(title = "Income"),
         
# Create dropwdown menus to allow selection of parameters on x-axis and y-axis 
         updatemenus = list(list(type = "dropdown",
                                 direction = "up",
                                 xanchor = "left",
                                 yanchor = "top",
                                 x = 1,
                                 y = 0,
                                 buttons = list(
                                   list(method = "update",
                                        args = list(list(x = list(combined$age_groups)),
                                                    list(xaxis = list(title = "Age Groups"))),
                                        label = "Age Groups"),
                                   list(method = "update",
                                        args = list(list(x = list(combined$haveKids)),
                                                    list(xaxis = list(title = "Have Kids"))),
                                        label = "Have Kids"),
                                   list(method = "update",
                                        args = list(list(x = list(combined$householdSize)),
                                                    list(xaxis = list(title = "Household Size"))),
                                        label = "Household Size"),
                                   list(method = "update",
                                        args = list(list(x = list(combined$educationLevel)),
                                                    list(xaxis = list(title = "Education Level"))),
                                        label = "Education Level"),
                                   list(method = "update",
                                        args = list(list(x = list(combined$interestGroup)),
                                                    list(xaxis = list(title = "Interest Group"))),
                                        label = "Interest Group")
                                   )
                                 ),
                            
                            list(type = "dropdown",
                                 xanchor = "left",
                                 yanchor = "top",
                                 x = 0.04,
                                 y = 0.95,
                                 buttons = list(
                                   list(method = "update",
                                        args = list(list(y = list(combined$Wage)),
                                                    list(yaxis = list(title = "Income"))),
                                        label = "Income"),
                                   list(method = "update",
                                        args = list(list(y = list(combined$Food)),
                                                    list(yaxis = list(title = "Food"))),
                                        label = "Food"),
                                   list(method = "update",
                                        args = list(list(y = list(combined$Recreation)),
                                                    list(yaxis = list(title = "Recreation"))),
                                        label = "Recreation"),
                                   list(method = "update",
                                        args = list(list(y = list(combined$AdjustedShelter)),
                                                    list(yaxis = list(title = "Shelter"))),
                                        label = "Shelter"),
                                   list(method = "update",
                                        args = list(list(y = list(combined$Education)),
                                                    list(yaxis = list(title = "Education"))),
                                        label = "Education"),
                                   list(method = "update",
                                        args = list(list(y = list(combined$CostOfLiving)),
                                                    list(yaxis = list(title = "Cost of Living"))),
                                        label = "Cost of Living")
                                   )
                                 )
                            )
         )
```

::: callout-note
## Key Observations

-   Income seems to differ across residents of different education levels. Particularly, the income of residents with Graduate degree seem to be the highest, followed by residents with Bachelors degree, then residents with Low or High School or College.
-   For residents who have kids and have higher household sizes, the expenses that seem to make a difference are education and shelter expenses. Particularly, it is noted that only residents who have kids (and hence household size 3) bear the costs of education expenses. Shelter expenses also seem to be higher for residents who have kids and with bigger household sizes.
:::

### Statistical Test: Does Income differ by Education Level?

We want to confirm our hypothesis of whether Income differs by Education Level and test the following hypothesis:

> H0: Median of income is equal across education levels
>
> H1: Not all means are equal

We first check the normality of the income distribution by education levels by plotting the Q-Q Plots and performing the Shapiro-Wilk Normality Test. As the p-values from the Normality Test are less than our level of significance of 0.05, we reject the null hypothesis that the distributions are normally distributed.

```{r}
#| code-fold: true
#| code-summary: "Show code"

qq1 <- ggplot(data = combined,
       aes(sample = Wage, color = educationLevel)) +
  stat_qq() +
  stat_qq_line() +
  scale_color_manual(values = wes_palette("Chevalier1", type = "continuous")) +
  theme(legend.position="bottom",
        legend.justification = c("left")) +
  labs(x = "Theoretical Quantiles",
       y = "Sample Quantiles",
       title = "Normal Q-Q Plot")

sw_t1 <- combined %>% 
  group_by(educationLevel) %>% 
  shapiro_test(Wage) %>% 
  select(-variable) %>% 
  gt() %>% 
  gt::tab_header(title = "Shapiro-Wilk Normality Test")

tmp1 <- tempfile(fileext = ".png")
gtsave(sw_t1, tmp1)

table_png1 <- png::readPNG(tmp1, native = TRUE)

qq1 + table_png1
```

Given that our the distribution is not normal, we will use the non-parametric test that does not assume normality for our hypothesis testing. In this case, we will be performing the Kruskal-Wallis one-way ANOVA test.

```{r}
#| code-fold: true
#| code-summary: "Show code"

ggbetweenstats(
  data = combined,
  x = educationLevel,
  y = Wage,
  type = "nonparametric",
  mean.ci = TRUE,
  pairwise.comparisons = TRUE,
  pairwise.display = "significant",
  p.adjust.method = "fdr",
  messages = FALSE
)
```

::: callout-note
## Key Observations

As the p-value from the Kruskal-Wallis one-way ANOVA test is less than our level of significance of 0.05, we reject the null hypothesis that the median income is equal across all education levels. Pairwise test further confirmed that median income differs between all pairs of education levels, with Graduates having the highest median income, followed by Bachelors, High School or College, then the residents with Low education level.

With this information, the city managers may be able to provide more targeted assistance or grants to the group of residents with High School or College or Low education level.
:::

### Statistical Test: Does Shelter Expense differ by Household Size?

Next, we want to confirm whether shelter expenses differ by household size and test the following hypothesis.

> H0: Median of shelter expense is equal across household sizes
>
> H1: Not all means are equal

Similarly, we will check the normality of the shelter expense distribution by household size by plotting the Q-Q Plots and performing the Shapiro-Wilk Normality Test. As the p-values from the Normality Test are less than our level of significance of 0.05, we reject the null hypothesis that the distributions are normally distributed.

```{r}
#| code-fold: true
#| code-summary: "Show code"

qq2 <- ggplot(data = combined,
       aes(sample = AdjustedShelter, color = householdSize)) +
  stat_qq() +
  stat_qq_line() +
  scale_color_manual(values = wes_palette("Chevalier1", type = "continuous")) +
  theme(legend.position="bottom",
        legend.justification = c("left")) +
  labs(x = "Theoretical Quantiles",
       y = "Sample Quantiles",
       title = "Normal Q-Q Plot")

sw_t2 <- combined %>% 
  group_by(householdSize) %>% 
  shapiro_test(AdjustedShelter) %>% 
  select(-variable) %>% 
  gt() %>% 
  gt::tab_header(title = "Shapiro-Wilk Normality Test")

tmp2 <- tempfile(fileext = ".png")
gtsave(sw_t2, tmp2)

table_png2 <- png::readPNG(tmp2, native = TRUE)

qq2 + table_png2
```

Given that our the distribution is not normal, we will use the non-parametric test that does not assume normality for our hypothesis testing. In this case, we will be performing the Kruskal-Wallis one-way ANOVA test.

```{r}
#| code-fold: true
#| code-summary: "Show code"

ggbetweenstats(
  data = combined,
  x = householdSize,
  y = AdjustedShelter,
  type = "nonparametric",
  mean.ci = TRUE,
  pairwise.comparisons = TRUE,
  pairwise.display = "significant",
  p.adjust.method = "fdr",
  messages = FALSE
)
```

::: callout-note
## Key Observations

As the p-value from the Kruskal-Wallis one-way ANOVA test is less than our level of significance of 0.05, we reject the null hypothesis that the median shelter expense is equal across all household sizes. Pairwise test further confirmed that median shelter expenses differs between all pairs of household sizes, with residents having household size 2 having the highest median shelter expense, followed by household size 3, then household size 1.

Together with the earlier observation from the interactive boxplots that only residents who have kids (and hence household size 3) bear the costs of education expenses, the city managers may consider more reliefs on education and shelter expenses for families who have kids and bigger household sizes. This is especially considering that only about 28% of the population have kids and such reliefs could help to reduce some of the expense burden for families who wish to have kids.
:::

## Income vs Cost of Living over time

Last but not least, we also want to understand how the residents' income and cost of living, which is defined as the sum of all expenses including Shelter, Education, Food and Recreation, have changed over time. This is to find out whether there is any concern of cost inflation without commensurate increase in income. We can visualise this through the ridgeline plot below.

```{r}
#| code-fold: true
#| code-summary: "Show code"
#| fig-width: 12
#| fig-height: 10

# Extracting Wage and Cost of Living and changing to long format
wage_col_overtime <- financial_yearmth %>% 
  dplyr::select(participantId, yearmonth, Wage, CostOfLiving) %>%
  pivot_longer(cols = c("Wage", "CostOfLiving"),
               names_to = "Category",
               values_to = "Amount")

# Plotting ridgeline plot
ggplot(wage_col_overtime, aes(x = Amount, y = yearmonth, group = yearmonth)) +
  geom_density_ridges(data = filter(wage_col_overtime, Category == "Wage"),
                      fill = "#71a187",
                      alpha = 0.7) +
  geom_density_ridges(data = filter(wage_col_overtime, Category == "CostOfLiving"),
                      fill = "#ef2400",
                      alpha = 0.7) +
  theme_ridges() +
  theme(
    legend.position="none",
    axis.title.y = element_blank()
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  labs(title = "Ridgeline Plot of Cost of Living vs Income",
       x = "Amount")
```

# References

-   [gglorenz package](https://github.com/jjchern/gglorenz)
-   [Lorenz Curve](https://www.investopedia.com/terms/l/lorenz-curve.asp#:~:text=The%20Lorenz%20curve%20is%20a%20graphical%20representation%20of%20the%20distribution,higher%20the%20level%20of%20inequality)
-   [Visual Analytics of Resale Prices of Singapore Public Housing Properties](https://isss608-michaeldj.netlify.app/take-home_ex/take-home_ex03/take-home_ex03)
-   [Documentation for Boxplots in Plotly](https://plotly.com/r/reference/#box)

1
